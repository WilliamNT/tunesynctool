/* tslint:disable */
/* eslint-disable */
/**
 * tunesynctool web API
 * Web API wrapper for the tunesynctool Python package with some extra features.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CollectionPlaylistRead } from '../models';
// @ts-ignore
import type { CollectionTrackRead } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { PlaylistCreate } from '../models';
// @ts-ignore
import type { PlaylistMultiTrackInsert } from '../models';
// @ts-ignore
import type { PlaylistRead } from '../models';
// @ts-ignore
import type { SearchResultCollectionTrackRead } from '../models';
// @ts-ignore
import type { TrackRead } from '../models';
/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a track to a playlist on the specified provider.
         * @summary Add tracks to a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {PlaylistMultiTrackInsert} playlistMultiTrackInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrackToPlaylist: async (providerId: string, provider: string, playlistMultiTrackInsert: PlaylistMultiTrackInsert, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('addTrackToPlaylist', 'providerId', providerId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('addTrackToPlaylist', 'provider', provider)
            // verify required parameter 'playlistMultiTrackInsert' is not null or undefined
            assertParamExists('addTrackToPlaylist', 'playlistMultiTrackInsert', playlistMultiTrackInsert)
            const localVarPath = `/api/playlists/{provider_id}/tracks`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistMultiTrackInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new playlist on the specified provider.  To keep things uniform, you cannot add initial tracks to the playlist because not all providers support this.
         * @summary Create a new playlist
         * @param {string} provider 
         * @param {PlaylistCreate} playlistCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (provider: string, playlistCreate: PlaylistCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('createPlaylist', 'provider', provider)
            // verify required parameter 'playlistCreate' is not null or undefined
            assertParamExists('createPlaylist', 'playlistCreate', playlistCreate)
            const localVarPath = `/api/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a playlist by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: async (providerId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getPlaylist', 'providerId', providerId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getPlaylist', 'provider', provider)
            const localVarPath = `/api/playlists/{provider_id}`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported. - This endpoint is not suitable to retrieve the user\'s saved tracks. Use the appropriate endpoint for that.
         * @summary Get all tracks from a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistTracks: async (providerId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getPlaylistTracks', 'providerId', providerId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getPlaylistTracks', 'provider', provider)
            const localVarPath = `/api/playlists/{provider_id}/tracks`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all playlists the user owns or has saved to their library on the specified provider. Keep in mind that results may not be exhaustive. Some providers may not return all playlists like those that are automatically generated.  Notes: - YouTube does not support retrieving playlists that are saved but **not owned** by the linked account. - YouTube results are not filtered to only contain music related playlists (e.g. any owned playlist will be returned). - This endpoint doesn\'t return the \"liked music\" playlist for all providers. Use the appropriate endpoint for that.
         * @summary Get playlists owned (and saved) by the user
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedPlaylists: async (provider: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getSavedPlaylists', 'provider', provider)
            const localVarPath = `/api/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user\'s saved tracks (aka. liked music) on the specified provider.
         * @summary Get the user\'s saved (liked) tracks at a provider
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedTracks: async (provider: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getSavedTracks', 'provider', provider)
            const localVarPath = `/api/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a track by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a track by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrack: async (providerId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getTrack', 'providerId', providerId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getTrack', 'provider', provider)
            const localVarPath = `/api/tracks/{provider_id}`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search using the specified provider by a specific ISRC identifier. This is basically a proxy.  Notes: - Not all providers support direct ISRC search. If this is the case, an error will be returned.
         * @summary Get a track by its ISRC
         * @param {string} isrc 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackByISRC: async (isrc: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isrc' is not null or undefined
            assertParamExists('getTrackByISRC', 'isrc', isrc)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getTrackByISRC', 'provider', provider)
            const localVarPath = `/api/isrc/{isrc}`
                .replace(`{${"isrc"}}`, encodeURIComponent(String(isrc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search using the specified provider. This is basically a proxy.  Results are returned in the order they are received from the provider, meaning you should not rely on their order.  Notes: - Content other than **tracks** (e.g. podcasts, albums, etc.) are omitted from the results if this type of filtering is supported by the provider. - For YouTube, results are limited to **any video** that belongs to the \"**Music**\" category. This means that the results may include irrelevant content. - YouTube results may include results from \"Topic\" channels, which are not actual artist channels.
         * @summary Search for tracks
         * @param {string} provider 
         * @param {string} query 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTracks: async (provider: string, query: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('searchTracks', 'provider', provider)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchTracks', 'query', query)
            const localVarPath = `/api/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a track to a playlist on the specified provider.
         * @summary Add tracks to a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {PlaylistMultiTrackInsert} playlistMultiTrackInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTrackToPlaylist(providerId: string, provider: string, playlistMultiTrackInsert: PlaylistMultiTrackInsert, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTrackToPlaylist(providerId, provider, playlistMultiTrackInsert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.addTrackToPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new playlist on the specified provider.  To keep things uniform, you cannot add initial tracks to the playlist because not all providers support this.
         * @summary Create a new playlist
         * @param {string} provider 
         * @param {PlaylistCreate} playlistCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(provider: string, playlistCreate: PlaylistCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(provider, playlistCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.createPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a playlist by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist(providerId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist(providerId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported. - This endpoint is not suitable to retrieve the user\'s saved tracks. Use the appropriate endpoint for that.
         * @summary Get all tracks from a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistTracks(providerId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistTracks(providerId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getPlaylistTracks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all playlists the user owns or has saved to their library on the specified provider. Keep in mind that results may not be exhaustive. Some providers may not return all playlists like those that are automatically generated.  Notes: - YouTube does not support retrieving playlists that are saved but **not owned** by the linked account. - YouTube results are not filtered to only contain music related playlists (e.g. any owned playlist will be returned). - This endpoint doesn\'t return the \"liked music\" playlist for all providers. Use the appropriate endpoint for that.
         * @summary Get playlists owned (and saved) by the user
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedPlaylists(provider: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionPlaylistRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedPlaylists(provider, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getSavedPlaylists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the user\'s saved tracks (aka. liked music) on the specified provider.
         * @summary Get the user\'s saved (liked) tracks at a provider
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedTracks(provider: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedTracks(provider, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getSavedTracks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a track by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a track by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrack(providerId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrack(providerId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getTrack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search using the specified provider by a specific ISRC identifier. This is basically a proxy.  Notes: - Not all providers support direct ISRC search. If this is the case, an error will be returned.
         * @summary Get a track by its ISRC
         * @param {string} isrc 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackByISRC(isrc: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackByISRC(isrc, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.getTrackByISRC']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search using the specified provider. This is basically a proxy.  Results are returned in the order they are received from the provider, meaning you should not rely on their order.  Notes: - Content other than **tracks** (e.g. podcasts, albums, etc.) are omitted from the results if this type of filtering is supported by the provider. - For YouTube, results are limited to **any video** that belongs to the \"**Music**\" category. This means that the results may include irrelevant content. - YouTube results may include results from \"Topic\" channels, which are not actual artist channels.
         * @summary Search for tracks
         * @param {string} provider 
         * @param {string} query 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTracks(provider: string, query: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultCollectionTrackRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTracks(provider, query, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.searchTracks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogApiFp(configuration)
    return {
        /**
         * Add a track to a playlist on the specified provider.
         * @summary Add tracks to a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {PlaylistMultiTrackInsert} playlistMultiTrackInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrackToPlaylist(providerId: string, provider: string, playlistMultiTrackInsert: PlaylistMultiTrackInsert, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead> {
            return localVarFp.addTrackToPlaylist(providerId, provider, playlistMultiTrackInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new playlist on the specified provider.  To keep things uniform, you cannot add initial tracks to the playlist because not all providers support this.
         * @summary Create a new playlist
         * @param {string} provider 
         * @param {PlaylistCreate} playlistCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(provider: string, playlistCreate: PlaylistCreate, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistRead> {
            return localVarFp.createPlaylist(provider, playlistCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a playlist by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistRead> {
            return localVarFp.getPlaylist(providerId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported. - This endpoint is not suitable to retrieve the user\'s saved tracks. Use the appropriate endpoint for that.
         * @summary Get all tracks from a playlist
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistTracks(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead> {
            return localVarFp.getPlaylistTracks(providerId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all playlists the user owns or has saved to their library on the specified provider. Keep in mind that results may not be exhaustive. Some providers may not return all playlists like those that are automatically generated.  Notes: - YouTube does not support retrieving playlists that are saved but **not owned** by the linked account. - YouTube results are not filtered to only contain music related playlists (e.g. any owned playlist will be returned). - This endpoint doesn\'t return the \"liked music\" playlist for all providers. Use the appropriate endpoint for that.
         * @summary Get playlists owned (and saved) by the user
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedPlaylists(provider: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CollectionPlaylistRead> {
            return localVarFp.getSavedPlaylists(provider, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user\'s saved tracks (aka. liked music) on the specified provider.
         * @summary Get the user\'s saved (liked) tracks at a provider
         * @param {string} provider 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedTracks(provider: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead> {
            return localVarFp.getSavedTracks(provider, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a track by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
         * @summary Get a track by its ID
         * @param {string} providerId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrack(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<TrackRead> {
            return localVarFp.getTrack(providerId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Search using the specified provider by a specific ISRC identifier. This is basically a proxy.  Notes: - Not all providers support direct ISRC search. If this is the case, an error will be returned.
         * @summary Get a track by its ISRC
         * @param {string} isrc 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackByISRC(isrc: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<TrackRead> {
            return localVarFp.getTrackByISRC(isrc, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Search using the specified provider. This is basically a proxy.  Results are returned in the order they are received from the provider, meaning you should not rely on their order.  Notes: - Content other than **tracks** (e.g. podcasts, albums, etc.) are omitted from the results if this type of filtering is supported by the provider. - For YouTube, results are limited to **any video** that belongs to the \"**Music**\" category. This means that the results may include irrelevant content. - YouTube results may include results from \"Topic\" channels, which are not actual artist channels.
         * @summary Search for tracks
         * @param {string} provider 
         * @param {string} query 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTracks(provider: string, query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultCollectionTrackRead> {
            return localVarFp.searchTracks(provider, query, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - interface
 * @export
 * @interface CatalogApi
 */
export interface CatalogApiInterface {
    /**
     * Add a track to a playlist on the specified provider.
     * @summary Add tracks to a playlist
     * @param {string} providerId 
     * @param {string} provider 
     * @param {PlaylistMultiTrackInsert} playlistMultiTrackInsert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    addTrackToPlaylist(providerId: string, provider: string, playlistMultiTrackInsert: PlaylistMultiTrackInsert, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead>;

    /**
     * Create a new playlist on the specified provider.  To keep things uniform, you cannot add initial tracks to the playlist because not all providers support this.
     * @summary Create a new playlist
     * @param {string} provider 
     * @param {PlaylistCreate} playlistCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    createPlaylist(provider: string, playlistCreate: PlaylistCreate, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistRead>;

    /**
     * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
     * @summary Get a playlist by its ID
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getPlaylist(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistRead>;

    /**
     * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported. - This endpoint is not suitable to retrieve the user\'s saved tracks. Use the appropriate endpoint for that.
     * @summary Get all tracks from a playlist
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getPlaylistTracks(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead>;

    /**
     * Returns all playlists the user owns or has saved to their library on the specified provider. Keep in mind that results may not be exhaustive. Some providers may not return all playlists like those that are automatically generated.  Notes: - YouTube does not support retrieving playlists that are saved but **not owned** by the linked account. - YouTube results are not filtered to only contain music related playlists (e.g. any owned playlist will be returned). - This endpoint doesn\'t return the \"liked music\" playlist for all providers. Use the appropriate endpoint for that.
     * @summary Get playlists owned (and saved) by the user
     * @param {string} provider 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getSavedPlaylists(provider: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CollectionPlaylistRead>;

    /**
     * Returns the user\'s saved tracks (aka. liked music) on the specified provider.
     * @summary Get the user\'s saved (liked) tracks at a provider
     * @param {string} provider 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getSavedTracks(provider: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTrackRead>;

    /**
     * Retrieve a track by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
     * @summary Get a track by its ID
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getTrack(providerId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<TrackRead>;

    /**
     * Search using the specified provider by a specific ISRC identifier. This is basically a proxy.  Notes: - Not all providers support direct ISRC search. If this is the case, an error will be returned.
     * @summary Get a track by its ISRC
     * @param {string} isrc 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    getTrackByISRC(isrc: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<TrackRead>;

    /**
     * Search using the specified provider. This is basically a proxy.  Results are returned in the order they are received from the provider, meaning you should not rely on their order.  Notes: - Content other than **tracks** (e.g. podcasts, albums, etc.) are omitted from the results if this type of filtering is supported by the provider. - For YouTube, results are limited to **any video** that belongs to the \"**Music**\" category. This means that the results may include irrelevant content. - YouTube results may include results from \"Topic\" channels, which are not actual artist channels.
     * @summary Search for tracks
     * @param {string} provider 
     * @param {string} query 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApiInterface
     */
    searchTracks(provider: string, query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchResultCollectionTrackRead>;

}

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI implements CatalogApiInterface {
    /**
     * Add a track to a playlist on the specified provider.
     * @summary Add tracks to a playlist
     * @param {string} providerId 
     * @param {string} provider 
     * @param {PlaylistMultiTrackInsert} playlistMultiTrackInsert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public addTrackToPlaylist(providerId: string, provider: string, playlistMultiTrackInsert: PlaylistMultiTrackInsert, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).addTrackToPlaylist(providerId, provider, playlistMultiTrackInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new playlist on the specified provider.  To keep things uniform, you cannot add initial tracks to the playlist because not all providers support this.
     * @summary Create a new playlist
     * @param {string} provider 
     * @param {PlaylistCreate} playlistCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public createPlaylist(provider: string, playlistCreate: PlaylistCreate, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).createPlaylist(provider, playlistCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
     * @summary Get a playlist by its ID
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPlaylist(providerId: string, provider: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getPlaylist(providerId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a playlist by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported. - This endpoint is not suitable to retrieve the user\'s saved tracks. Use the appropriate endpoint for that.
     * @summary Get all tracks from a playlist
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPlaylistTracks(providerId: string, provider: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getPlaylistTracks(providerId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all playlists the user owns or has saved to their library on the specified provider. Keep in mind that results may not be exhaustive. Some providers may not return all playlists like those that are automatically generated.  Notes: - YouTube does not support retrieving playlists that are saved but **not owned** by the linked account. - YouTube results are not filtered to only contain music related playlists (e.g. any owned playlist will be returned). - This endpoint doesn\'t return the \"liked music\" playlist for all providers. Use the appropriate endpoint for that.
     * @summary Get playlists owned (and saved) by the user
     * @param {string} provider 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getSavedPlaylists(provider: string, limit?: number, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getSavedPlaylists(provider, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user\'s saved tracks (aka. liked music) on the specified provider.
     * @summary Get the user\'s saved (liked) tracks at a provider
     * @param {string} provider 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getSavedTracks(provider: string, limit?: number, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getSavedTracks(provider, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a track by its ID from the specified provider. This is basically a proxy.  Notes: - Some providers (like Spotify) may support multiple ID formats. In these cases, all formats are supported.
     * @summary Get a track by its ID
     * @param {string} providerId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getTrack(providerId: string, provider: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getTrack(providerId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search using the specified provider by a specific ISRC identifier. This is basically a proxy.  Notes: - Not all providers support direct ISRC search. If this is the case, an error will be returned.
     * @summary Get a track by its ISRC
     * @param {string} isrc 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getTrackByISRC(isrc: string, provider: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getTrackByISRC(isrc, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search using the specified provider. This is basically a proxy.  Results are returned in the order they are received from the provider, meaning you should not rely on their order.  Notes: - Content other than **tracks** (e.g. podcasts, albums, etc.) are omitted from the results if this type of filtering is supported by the provider. - For YouTube, results are limited to **any video** that belongs to the \"**Music**\" category. This means that the results may include irrelevant content. - YouTube results may include results from \"Topic\" channels, which are not actual artist channels.
     * @summary Search for tracks
     * @param {string} provider 
     * @param {string} query 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public searchTracks(provider: string, query: string, limit?: number, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).searchTracks(provider, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

